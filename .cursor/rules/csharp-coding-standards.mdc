# C# ì½”ë”© í‘œì¤€ (Unity)

## ğŸ“ ë„¤ì´ë° ê·œì¹™

### í´ë˜ìŠ¤ ë° ì¸í„°í˜ì´ìŠ¤

- í´ë˜ìŠ¤: PascalCase (ì˜ˆ: `PlayerController`, `GameManager`)
- ì¸í„°í˜ì´ìŠ¤: `I` ì ‘ë‘ì‚¬ + PascalCase (ì˜ˆ: `IEvent`, `IState<T>`)
- ì¶”ìƒ í´ë˜ìŠ¤: PascalCase (ì˜ˆ: `RouteNames`)

### ë©”ì„œë“œ ë° ì†ì„±

- Public ë©”ì„œë“œ: PascalCase (ì˜ˆ: `OnEventHandle`, `Execute`)
- Private ë©”ì„œë“œ: camelCase (ì˜ˆ: `handleInput`, `updatePosition`)
- ì†ì„±: PascalCase (ì˜ˆ: `gameObject`, `isLogging`)

### ë³€ìˆ˜

- Public í•„ë“œ: PascalCase
- Private í•„ë“œ: camelCase (ì˜ˆ: `previousState`, `currentState`)
- ìƒìˆ˜: UPPER_SNAKE_CASE (ì˜ˆ: `MAX_COUNT`, `DEFAULT_DELAY`)

## ğŸ”§ Unity íŠ¹í™” ê·œì¹™

### MonoBehaviour ì‚¬ìš©

```csharp
// âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
public class PlayerController : MonoBehaviour
{
    [SerializeField] private Button playButton;

    private void Awake()
    {
        // ì´ˆê¸°í™” ë¡œì§
    }

    private void Start()
    {
        // ì‹œì‘ ë¡œì§
    }
}
```

### ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ

```csharp
// ì´ë²¤íŠ¸ êµ¬ì¡°ì²´ ì •ì˜
public struct OnClickStartGameEvent : IEvent
{
}

// ì´ë²¤íŠ¸ ë””ìŠ¤íŒ¨ì²˜ êµ¬í˜„
public class HomeCanvas : MonoBehaviour, IMonoEventDispatcher
{
    [SerializeField] private Button playButton;

    private void Awake()
    {
        playButton.onClick.AddListener(this.Emit<OnClickStartGameEvent>);
    }
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ êµ¬í˜„
public class HomeController : MonoBehaviour, IMonoEventListener
{
    public EventChain OnEventHandle(IEvent param)
    {
        if (param is OnClickStartGameEvent)
        {
            // ì´ë²¤íŠ¸ ì²˜ë¦¬
            return EventChain.Break;
        }
        return EventChain.Continue;
    }
}
```

### ìƒíƒœ ë¨¸ì‹  íŒ¨í„´

```csharp
// ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
public class PlayerState : IState<PlayerState>
{
    protected PlayerController player;

    public PlayerState(PlayerController player)
    {
        this.player = player;
    }

    public virtual UniTask<PlayerState> Enter(PlayerState previousState)
        => UniTask.FromResult<PlayerState>(null);

    public virtual UniTask Exit(PlayerState nextState)
        => UniTask.CompletedTask;
}
```

## ğŸš€ ì„±ëŠ¥ ìµœì í™”

### ë©”ëª¨ë¦¬ ê´€ë¦¬

- `using` ë¬¸ ì‚¬ìš©ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ í•´ì œ
- ì˜¤ë¸Œì íŠ¸ í’€ë§ ê³ ë ¤
- ë¶ˆí•„ìš”í•œ GC í• ë‹¹ ë°©ì§€

### ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°

- UniTask ì‚¬ìš© ê¶Œì¥
- `async/await` íŒ¨í„´ í™œìš©
- ì½”ë£¨í‹´ ëŒ€ì‹  UniTask ì„ í˜¸

## ğŸ“š ë¬¸ì„œí™”

### XML ë¬¸ì„œí™”

```csharp
/// <summary>
/// í”Œë ˆì´ì–´ì˜ ìƒíƒœë¥¼ ê´€ë¦¬í•˜ëŠ” ìƒíƒœ ë¨¸ì‹ 
/// </summary>
/// <typeparam name="T">ìƒíƒœ íƒ€ì…</typeparam>
public interface IState<T>
{
    /// <summary>
    /// ìƒíƒœì— ì§„ì…í•  ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤
    /// </summary>
    /// <param name="previousState">ì´ì „ ìƒíƒœ</param>
    /// <returns>ë‹¤ìŒ ìƒíƒœ ë˜ëŠ” null (ì¢…ë£Œ)</returns>
    UniTask<T> Enter(T previousState);

    /// <summary>
    /// ìƒíƒœë¥¼ ë‚˜ê°ˆ ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤
    /// </summary>
    /// <param name="nextState">ë‹¤ìŒ ìƒíƒœ</param>
    UniTask Exit(T nextState);
}
```

### ì¸ë¼ì¸ ì£¼ì„

```csharp
// ìƒíƒœ ë¨¸ì‹  ì‹¤í–‰
while (currentState != null)
{
    // ì´ì „ ìƒíƒœ ì¢…ë£Œ ì²˜ë¦¬
    if (previousState != null)
    {
        await previousState.Exit(currentState);
    }

    // ë¡œê¹… (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ)
    if (isLogging)
    {
        Debug.Log($"ìƒˆë¡œìš´ ìƒíƒœ ì§„ì…: {currentState.GetType().Name}");
    }

    // í˜„ì¬ ìƒíƒœ ì‹¤í–‰ ë° ë‹¤ìŒ ìƒíƒœ ê²°ì •
    var nextState = await currentState.Enter(previousState);
    previousState = currentState;
    currentState = nextState;
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

- ê° Featureë³„ í…ŒìŠ¤íŠ¸ ì‘ì„±
- Mock ê°ì²´ í™œìš©
- ë¹„ë™ê¸° í…ŒìŠ¤íŠ¸ ê³ ë ¤

### í†µí•© í…ŒìŠ¤íŠ¸

- ì”¬ ê°„ ì „í™˜ í…ŒìŠ¤íŠ¸
- ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
- ìƒíƒœ ë¨¸ì‹  í…ŒìŠ¤íŠ¸
  description:
  globs:
  alwaysApply: true

---
